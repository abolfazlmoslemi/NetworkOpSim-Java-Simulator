// FILE: /NetworkOpSim-Multiplayer/NetworkOpSim-Server/src/main/java/com/networkopsim/server/handling/ExceptionHandlingProxy.java
// ================================================================================

package com.networkopsim.server.handling;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.function.Consumer;

/**
 * A dynamic proxy that intercepts method calls to a target object,
 * catching any exceptions and delegating them to an ExceptionDispatcher.
 */
public class ExceptionHandlingProxy implements InvocationHandler {

    private final Object target;
    private final ExceptionDispatcher dispatcher;
    private final Consumer<Object> responseConsumer;

    private ExceptionHandlingProxy(Object target, Consumer<Object> responseConsumer, String handlerPackage) {
        this.target = target;
        this.dispatcher = new ExceptionDispatcher(handlerPackage);
        this.responseConsumer = responseConsumer;
    }

    /**
     * The core method of the proxy. It is called for every method invocation on the proxy instance.
     * It wraps the actual method call in a try-catch block.
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        try {
            // Invoke the actual method on the original target object
            return method.invoke(target, args);
        } catch (Throwable t) {
            // If an exception occurs, unwrap it (InvocationTargetException wraps the real one)
            Throwable actualException = t instanceof InvocationTargetException ? t.getCause() : t;

            // Dispatch the actual exception to the global handler
            Object response = dispatcher.dispatch(actualException);

            // If the handler produced a response, send it back to the client
            if (response != null && responseConsumer != null) {
                responseConsumer.accept(response);
            } else {
                // If no response is generated, we still log that an exception was caught
                // to avoid silent failures.
                System.err.println("Proxy caught an exception but no response was generated by the handler: " + actualException.getMessage());
            }

            // We consume the exception here and return null to prevent it from propagating further.
            // Adjust return type if methods are expected to return non-null primitives.
            return null;
        }
    }

    /**
     * A factory method to create a proxy instance for a given target object that implements interfaces.
     *
     * @param target           The object to be proxied.
     * @param responseConsumer A function that knows how to send a response object (e.g., ServerResponse) back to the client.
     * @param handlerPackage   The package where the @ControllerAdvice class is located.
     * @param <T>              The type of the interface.
     * @return A proxy instance that wraps the target object.
     */
    @SuppressWarnings("unchecked")
    public static <T> T createProxy(Object target, Consumer<Object> responseConsumer, String handlerPackage, Class<T> interfaceType) {
        if (!interfaceType.isInterface()) {
            throw new IllegalArgumentException("Proxy target must be an interface.");
        }
        return (T) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                new Class<?>[]{interfaceType}, // Proxy based on the specified interface
                new ExceptionHandlingProxy(target, responseConsumer, handlerPackage)
        );
    }
}